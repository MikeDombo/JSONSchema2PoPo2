from reprlib import repr as limitedRepr
{% macro get_type(prop, parent=True, sub=True, fullPath=True) %}{{ python_type(parent and prop.definition or sub and
 prop.definition.item_type or sub and prop.definition.item_type or prop.definition or None, parent=fullPath)}}
{%- endmacro %}
{% macro get_typing(prop) %}
{% if prop.definition.m_type == 'list' and prop.definition.string_item_type %}List[{{ get_type(prop, parent=False, fullPath=False) }}]
{% else %}{{ get_type(prop, parent=False, fullPath=False) }}{% endif %}{% endmacro %}

{% macro type_check(prop, name=None) %}
{% if prop.definition.m_type %}
if {% if not prop.validations.required %}{{ name or prop.name }} is not None and {% endif %} not isinstance({{ name or prop.name }}, {{ get_type(prop, parent=prop.definition.m_type != "list", sub=False) }}):
    raise TypeError("{{prop.name}} must be {{ get_type(prop, parent=prop.definition.m_type != "list", sub=False) }}")
{% endif %}
{% if prop.definition and prop.definition.m_type and prop.definition.m_type == 'list' %}
if {% if not prop.validations.required %}{{ name or prop.name }} is not None and {% endif %} not all(isinstance(i, {{get_type(prop, parent=False) }}) for i in {% if name %}{{ name }}{% else %}{{ prop.name }}{% endif %}):
    raise TypeError("{{prop.name}} list values must be {{ get_type(prop, parent=False) }}")
{% endif %}
{% endmacro %}

{% if enum_used %}
import enum
{% endif %}
{% if use_types and list_used %}
from typing import List
{% endif %}

{% macro generate_class(model) %}
class {{model.python_type_name}}{% if model.m_type == "enum" %}(enum.Enum){% endif %}{% if model.extends %}({{ model.extends.full_name_python_path}}){%endif %}:
{% if model.comment %}
    """
    {{ model.comment | indent(4) }}
    """
{% endif %}
{% for child in model.children %}
    {{ generate_class(child)|indent(8) }}
{% endfor %}

{% if use_slots and not model.m_type == "enum" %}
    __slots__ = [{% for prop in model.properties %}"__{{ prop.name }}", {% endfor %}]
{% endif %}

{% if model.m_type == "enum" %}
{% for name, value in model.values.items() %}
    {{name}} = {% if model.value_type.m_type == "string" %}"{{value}}"{% elif model.value_type.m_type == "integer" or model.value_type.m_type == "number" %}{{value}}{% endif %}

{% endfor %}
{% endif %}

{% if model.properties %}
    _types_map = {
{% for prop in model.properties %}
        '{{prop.name}}': {'type': {{python_type(prop.definition or None, False)}}, 'subtype': {{python_type(prop.definition.item_type or None, False)}}},
{% endfor %}
    }
    _formats_map = {
{% for prop in model.properties if prop.format %}
        '{{prop.name}}': '{{prop.format}}',
{% endfor %}
    }
    _validations_map = {
{% for prop in model.properties if prop.validations %}
        '{{ prop.name }}': { {% for type, value in prop.validations.items() %}'{{ type }}': {% if type == "pattern" %}'{{ value }}'{% else %}{{ value }}{% endif %},{% endfor %}},
{% endfor %}
    }
{% endif %}

{% if not model.m_type == "enum" %}
    def __init__(self
{% if model.extends %}
            , *args
{% endif %}
{% for prop in model.properties %}
            , {{prop.name}}{% if use_types %}: {{ get_typing(prop) }}{% endif %}={{prop.default}}
{% endfor %}
{% if model.extends %}
            , **kwargs
{% endif %}
            ):
{% if model.properties_have_comments %}
        """
{% for prop in model.properties %}
{% if prop.comment %}
        :param {{ prop.name }}: {{ prop.comment | indent(12) }}
{% endif %}
{% endfor %}
        """
{% endif %}
{% if model.extends %}
        super().__init__(*args, **kwargs)
{% endif %}
        pass
{% if constructor_type_check %}
{% for prop in model.properties %}
        {{ type_check(prop)|indent(8) }}
{% endfor %}
{% endif %}
{% for prop in model.properties %}
        self.__{{prop.name}} = {{prop.name}}
{% endfor %}
{% endif %}
    
{% for prop in model.properties %}
    def _get_{{prop.name}}(self):
        return self.__{{prop.name}}
    def _set_{{prop.name}}(self, value):
        {{ type_check(prop, "value")|indent(8) }}
        self.__{{prop.name}} = value
    {{prop.name}} = property(_get_{{prop.name}}, _set_{{prop.name}})
{% if prop.comment %}
    """
    {{ prop.comment | indent(4) }}
    """
{% endif %}
    
{% endfor %}

    @staticmethod
    def from_dict(d):
{% if model.m_type == "enum" %}
        return {{ model.full_name_python_path }}(d)
{% else %}
{% if model.extends %}
        v = d.copy()
{% else %}
        v = {}
{% endif %}
{% for prop in model.properties %}
        if "{{ prop.name }}" in d:
{% if prop.definition.m_type == 'list' %}
            v["{{ prop.name }}"] = [{{ get_type(prop, parent=False) }}.from_dict(p) if hasattr({{ get_type(prop, parent=False) }}, 'from_dict') else p for p in d["{{ prop.name }}"]]
{% else %}
            v["{{ prop.name }}"] = {{ get_type(prop) }}.from_dict(d["{{prop.name}}"]) if hasattr({{ get_type(prop) }}, 'from_dict') else d["{{ prop.name }}"]
{% endif %}
{% endfor %}
        return {{ model.full_name_python_path }}(**v)
{% endif %}


    def as_dict(self):
{% if model.m_type == "enum" %}
        return self.value
{% else %}
{% if model.extends %}
        d = super().as_dict()
{% else %}
        d = {}
{% endif %}
{% for prop in model.properties %}
        if self.__{{prop.name}} is not None:
{% if prop.definition.m_type == 'list' %}
            d['{{prop.name}}'] = [p.as_dict() if hasattr(p, 'as_dict') else p for p in self.__{{prop.name}}]
{% else %}
            d['{{prop.name}}'] = self.__{{prop.name}}.as_dict() if hasattr(self.__{{prop.name}}, 'as_dict') else self.__{{prop.name}}
{% endif %}
{% endfor %}
        return d
{% endif %}

    def __repr__(self):
{% if model.m_type == "enum" %}
        return "<Enum {{model.python_type_name}}. {}: {}>".format(limitedRepr(self.name), limitedRepr(self.value))
{% else %}
        return "<Class {{model.python_type_name}}. {{ model.properties|map(attribute="name")|map('regex_replace', '(.+)', '\\1: {}')|join(', ') }}>".format({{ model.properties|map(attribute="name")|map('regex_replace', '(.+)', 'limitedRepr(self.__\\1[:20] if isinstance(self.__\\1, bytes) else self.__\\1)')|join(', ') }})
{% endif %}
{% endmacro %}


{% for model in models %}
{{ generate_class(model) }}
{% endfor %}
